<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Generator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            /*max-width: 600px;*/
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .input-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-row .input-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #007bff;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        /*button.stop-button {*/
        /*    background-color: #dc3545;*/
        /*}*/

        /*button.stop-button:hover {*/
        /*    background-color: #c82333;*/
        /*}*/

        .animation-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .checkbox-item {
            display: inline-block;
            margin: 5px 10px;
            white-space: nowrap;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }

        .checkbox-item label {
            cursor: pointer;
            user-select: none;
            font-weight: normal;
            margin-bottom: 0;
        }

        .checkbox-item input[type="checkbox"]:checked + label {
            color: #007bff;
            font-weight: bold;
        }

        #revolveBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed !important;
            background: linear-gradient(145deg, #ccc, #aaa) !important;
            transform: none !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:hover:not(:disabled) {
            transform: translateY(-3px);
        }

        #revolveBtn:hover:not(:disabled)[style*="linear-gradient(145deg, #4a90e2"] {
            background: linear-gradient(145deg, #5ba0f2, #4080cd) !important;
            box-shadow: 0 12px 24px rgba(74, 144, 226, 0.5), 0 6px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:hover:not(:disabled)[style*="linear-gradient(145deg, #dc3545"] {
            background: linear-gradient(145deg, #e74c3c, #d63031) !important;
            box-shadow: 0 12px 24px rgba(220, 53, 69, 0.5), 0 6px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        #revolveBtn:active:not(:disabled)[style*="linear-gradient(145deg, #4a90e2"] {
            box-shadow: 0 4px 8px rgba(74, 144, 226, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.3) !important;
        }

        #revolveBtn:active:not(:disabled)[style*="linear-gradient(145deg, #dc3545"] {
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.3) !important;
        }

        #dimensionCheckboxes {
            border-top: 1px solid #ddd;
            padding-top: 20px;
            margin-top: 20px;
        }

        #checkboxContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin: 10px 0;
            justify-content: flex-start;
            align-items: center;
        }

        #canvas3d {
            border: 2px solid #ddd;
            margin-top: 10px;
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
            height: auto;
            box-sizing: border-box;
        }

        #canvasContainer {
            text-align: center;
            margin: 20px auto;
            width: 100%;
            max-width: 1600px;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .controls-row label {
            margin-bottom: 0;
            font-weight: normal;
        }

        #speedSlider {
            width: 150px;
            padding: 0;
        }

        #speedValue {
            font-weight: bold;
            color: #007bff;
            min-width: 40px;
        }

        /* Make container responsive */
        @media (max-width: 600px) {
            .controls-row {
                flex-direction: column;
                gap: 5px;
            }

            #speedSlider {
                width: 200px;
            }

            .input-row {
                flex-direction: column;
                gap: 10px;
            }
        }

        .button-row {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        /* Main container for input boxes and generate/tesseract buttons */
        .input-and-buttons-container {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-bottom: 20px;
        }

        /* Responsive controls container */
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .controls-container .button-row {
            margin-top: 0;
            flex: 1;
            min-width: 300px;
        }

        .controls-container #dimensionCheckboxes {
            flex: 1;
            min-width: 250px;
            margin-top: 0;
        }

        .controls-container #dimensionCheckboxes #revolveBtn {
            margin-top: 10px;
        }

        /* On smaller screens, stack vertically */
        @media (max-width: 800px) {
            .controls-container {
                flex-direction: column;
            }

            .controls-container .button-row,
            .controls-container #dimensionCheckboxes {
                min-width: 100%;
            }
        }

        .button-row button {
            flex: 1;
            background: linear-gradient(145deg, #4a90e2, #357abd);
            color: white;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            position: relative;

            /* 3D effect */
            box-shadow:
                0 8px 16px rgba(74, 144, 226, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);

            border-top: 1px solid rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(0, 0, 0, 0.3);
        }

        .button-row button:hover {
            background: linear-gradient(145deg, #5ba0f2, #4080cd);
            transform: translateY(-3px);
            box-shadow:
                0 12px 24px rgba(74, 144, 226, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:active {
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(74, 144, 226, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row button:nth-child(2) {
            background: linear-gradient(145deg, #5cb85c, #449d44);
            box-shadow:
                0 8px 16px rgba(92, 184, 92, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:nth-child(2):hover {
            background: linear-gradient(145deg, #6cc86c, #559d55);
            box-shadow:
                0 12px 24px rgba(92, 184, 92, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:nth-child(2):active {
            box-shadow:
                0 4px 8px rgba(92, 184, 92, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>n Dimensional rotation</h2>
        <form>
            <div class="input-and-buttons-container">
                <div class="input-row">
                    <div class="input-group">
                        <label for="numPoints">Specify number of points:</label>
                        <input type="number" id="numPoints" name="numPoints" min="1" placeholder="Enter number of points">
                    </div>
                    <div class="input-group">
                        <label for="numDimensions">Specify number of dimensions:</label>
                        <input type="number" id="numDimensions" name="numDimensions" min="1" placeholder="Enter number of dimensions" onchange="updateDimensionCheckboxes()">
                    </div>
                </div>
                <div class="button-row">
                    <button type="button" onclick="generatePoints()">Generate Random Points</button>
                    <button type="button" onclick="generateTesseract()">Generate Tesseract (4D Cube)</button>
                </div>
            </div>

            <div class="controls-container">
                <div id="dimensionCheckboxes" class="form-group" style="display: none;">
                    <label>Select axes to rotate around:</label>
                    <div id="checkboxContainer"></div>
                    <button type="button" id="revolveBtn" onclick="toggleRevolve()" style="margin-top: 10px; background: linear-gradient(145deg, #4a90e2, #357abd); color: white; padding: 16px 24px; border: none; border-radius: 12px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.8px; position: relative; box-shadow: 0 8px 16px rgba(74, 144, 226, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2); border-top: 1px solid rgba(255, 255, 255, 0.4); border-bottom: 2px solid rgba(0, 0, 0, 0.3);">Start Revolving</button>
                    <div class="animation-info">Tip: Press spacebar to start/stop rotation</div>
                </div>
            </div>
        </form>
    </div>
    <div id="canvasContainer" style="display: none;">
        <h3>3D Visualization</h3>
        <div class="controls-row">
            <label for="speedSlider">Rotation Speed:</label>
            <input type="range" id="speedSlider" min="0.1" max="20" step="0.1" value="5" oninput="updateRotationSpeed()">
            <span id="speedValue">1.0x</span>
        </div>
        <div class="controls-row">
            <label for="zoomSlider">Zoom Level:</label>
            <input type="range" id="zoomSlider" min="0.05" max="0.5" step="0.01" value="0.15" oninput="updateZoom()">
            <span id="zoomValue">0.15</span>
        </div>
        <div class="controls-row">
            <label for="trailLengthSlider">Trail Length:</label>
            <input type="range" id="trailLengthSlider" min="10" max="500" step="10" value="150" oninput="updateTrailLength()">
            <span id="trailLengthValue">150</span>
        </div>
        <div class="form-group">
            <label for="showTrails">Show point trails (trace paths):</label>
            <input type="checkbox" id="showTrails" >
        </div>
        <canvas id="canvas3d"></canvas>
        <p><small>Points sized by depth: closer = larger, farther = smaller</small></p>
    </div>
    <script type="module">
        let NDimensionalPoint, PointCollection, currentCollection ;

        // Animation variables
        let isRevolving = false;
        let animationId = null;
        const BASE_ROTATION_STEP = 1 / 180; // 0.5 degrees in radians
        let rotationSpeed = 1.0; // Speed multiplier
        let currentRotationStep = BASE_ROTATION_STEP;
        let currentRotationAmount = 0;
        let baseCollection ;
        let rotationMatrix;
        // Trail system variables
        let pointTrails = new Map(); // Store trails for each point
        let maxTrailLength = 150; // Maximum number of trail points to keep (adjustable by user)
        let nearestApproach = 1000;
        // Load modules with error handling
        try {
            console.log('Loading NDimensionalPoint.js...');
            const ndPointModule = await import('./NDimensionalPoint.js');
            console.log('NDimensionalPoint.js loaded successfully');

            console.log('Loading PointCollection.js...');
            const collectionModule = await import('./PointCollection.js');
            console.log('PointCollection.js loaded successfully');

            NDimensionalPoint = ndPointModule.default;
            PointCollection = collectionModule.default;
            console.log('Modules loaded successfully');
        } catch (error) {
            console.error('Error loading modules:', error);
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
            alert(`Error loading JavaScript modules: ${error.message}\n\nMake sure NDimensionalPoint.js and PointCollection.js exist in the same directory.`);
        }

        window.generatePoints = function() {
            try {
                const numPoints = document.getElementById('numPoints').value;
                const numDimensions = document.getElementById('numDimensions').value;

                if (!numPoints || numPoints < 1) {
                    alert('Please enter a valid number of points (1 or greater)');
                    return;
                }

                if (!numDimensions || numDimensions < 3) {
                    alert('Please enter at least 3 dimensions for 3D visualization');
                    return;
                }

                if (!NDimensionalPoint || !PointCollection) {
                    alert('JavaScript modules not loaded properly');
                    return;
                }

                // Create PointCollection and generate points within unit sphere
                currentCollection = new PointCollection();
                pointTrails = new Map(); // Clear previous trails
                generatePointsInUnitSphere(parseInt(numPoints), parseInt(numDimensions));

                // Show dimension checkboxes
                updateDimensionCheckboxes();
                document.getElementById('dimensionCheckboxes').style.display = 'block';

                // Show and render 3D visualization
                document.getElementById('canvasContainer').style.display = 'block';
                render3DPoints(currentCollection);

                alert(`Successfully generated ${numPoints} points with ${numDimensions} dimensions within unit distance of origin!`);
            } catch (error) {
                console.error('Error in generatePoints:', error);
                alert('Error generating points: ' + error.message);
            }
        }

        window.updateDimensionCheckboxes = function() {
            try {
                const numDimensions = document.getElementById('numDimensions').value;
                const container = document.getElementById('checkboxContainer');

                if (!container) {
                    console.error('Checkbox container not found');
                    return;
                }

                if (!numDimensions || numDimensions < 1) {
                    container.innerHTML = '';
                    document.getElementById('dimensionCheckboxes').style.display = 'none';
                    return;
                }

                container.innerHTML = '';

                for (let i = 0; i < parseInt(numDimensions); i++) {
                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = 'checkbox-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `dim${i}`;
                    checkbox.value = i.toString();

                    // Add event listener to detect changes
                    checkbox.addEventListener('change', function(event) {
                        onDimensionCheckboxChange(i, event.target.checked);
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `dim${i}`;

                    // Label dimensions: x, y, z, then w with subscripts
                    if (i === 0) {
                        label.textContent = 'x';
                    } else if (i === 1) {
                        label.textContent = 'y';
                    } else if (i === 2) {
                        label.textContent = 'z';
                    } else {
                        label.innerHTML = `w<sub>${i-2}</sub>`;
                    }

                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(label);
                    container.appendChild(checkboxItem);
                }
            } catch (error) {
                console.error('Error updating checkboxes:', error);
            }
        }

        function getCanvasInformation(canvas) {
            // Make canvas square and responsive
            const container = document.getElementById('canvasContainer');
            const containerWidth = container.clientWidth;

            // Calculate available height (window height minus other elements)
            const windowHeight = window.innerHeight;
            const canvasTop = canvas.getBoundingClientRect().top;
            const availableHeight = windowHeight - canvasTop - 40; // 40px for bottom margin

            // Use the smaller of available width or height to maintain square aspect ratio
            const maxSize = Math.min(containerWidth - 40, availableHeight);

            canvas.width = maxSize;
            canvas.height = maxSize;
            canvas.style.width = maxSize + 'px';
            canvas.style.height = maxSize + 'px';

            return maxSize;
        }

        function getViewpoint(){
            // Define viewpoint position (camera position) - get from slider
            const viewpointSlider = document.getElementById('viewpointZ');
            const viewpointDistance = viewpointSlider ? parseFloat(viewpointSlider.value) : 3;

            return {
                x: 0,    // Centered on X
                y: 0,    // Centered on Y
                z: viewpointDistance     // Distance from slider
            };

        }

        function trimNDimensionalPointTo3d(collectionOfPoints, viewpoint) {
            return collectionOfPoints.map(point => {
                const x = point.getCoordinate(0);
                const y = point.getCoordinate(1);
                const z = point.getCoordinate(2);

                // Calculate distance from viewpoint using 3D Euclidean distance
                const distanceFromViewpoint = Math.sqrt(
                        Math.pow(x - viewpoint.x, 2) +
                        Math.pow(y - viewpoint.y, 2) +
                        Math.pow(z - viewpoint.z, 2)
                );
                const distanceToOrigin = Math.sqrt(x * x + y * y + z * z);

                return {
                    x: x,
                    y: y,
                    z: z,
                    distanceFromViewpoint: distanceFromViewpoint,
                    distanceToOrigin: distanceToOrigin,
                    originalPoint: point
                };
            });
        }

         // 3D rendering functions
        function render3DPoints(currentCollection) {
            try {
                const canvas = document.getElementById('canvas3d');
                if (!canvas) {
                    console.error('Canvas not found');
                    return;
                }
                const maxSize = getCanvasInformation(canvas);
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                if (!currentCollection || currentCollection.size() === 0) {
                    return;
                }

                const points = currentCollection.getAllPoints();

                const viewpoint = getViewpoint();

                const points3D = trimNDimensionalPointTo3d(points, viewpoint);
                // Update trails with current positions
                updateTrails(points3D);


                // Get zoom level from slider
                const zoomSlider = document.getElementById('zoomSlider');
                const zoomLevel = zoomSlider ? parseFloat(zoomSlider.value) : 0.15;
                const fixedScale = Math.min(canvas.width, canvas.height) * zoomLevel;

                // Canvas center (this is where origin (0,0) will always be)
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;

                // Sort points by distance from viewpoint (farthest to nearest for proper rendering)
                //points3D.sort((a, b) => b.distanceFromViewpoint - a.distanceFromViewpoint);

                // Draw trails first (behind points)
                drawTrails(ctx);

                // Draw lines
                drawLines(ctx, points3D);

                // Draw origin crosshairs - these should always be at canvas center
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);

                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Count visible points
                let visiblePoints = 0;
                let totalPoints = points3D.length;

                // Find min/max distances for normalization
                const distances = points3D.slice(0,-1).map(p => p.distanceToOrigin);
                const farthestFromOrigin = Math.max(...distances);
                const nearestToOrigin = Math.min(...distances);
                const minDistance = viewpoint.z-farthestFromOrigin;
                const maxDistance = viewpoint.z+farthestFromOrigin;
                // when the farthest point is away from the viewpoint, it should be 1, when closest to the viewpoint, it should be max
                const distanceRange = maxDistance - minDistance;
                // Render points with size and color based on viewpoint distance
                points3D.forEach(point => {
                    // Map coordinates with fixed scale - origin (0,0) always at canvas center
                    const canvasX = centerX + (point.x * fixedScale);
                    const canvasY = centerY + (point.y * fixedScale);
                    if (point.x === 0 && point.y ===0 && point.z === 0) {
                        const color = `rgb(${0}, ${255}, ${0})`;
                        ctx.beginPath();
                        ctx.arc(canvasX, canvasY, 3, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();

                        return;
                    }

                    // Check if point is within viewport (including point size)
//                    const normalizedDistance = distanceRange > 0 ? 1 - ((point.distanceFromViewpoint - minDistance) / distanceRange) : 0.5;
                    const normalizedDistance = (distanceRange - (point.distanceFromViewpoint-minDistance)) / distanceRange ;

                    const minPointSize = Math.max(1, maxSize * 0.003);
                    const maxPointSizeCalc = Math.max(5, maxSize * 0.02);
                    const pointSize = minPointSize + normalizedDistance * (maxPointSizeCalc - minPointSize);

                    // Check if point (including its radius) is visible in viewport
                    const isVisible = (canvasX + pointSize >= 0 &&
                                     canvasX - pointSize <= canvas.width &&
                                     canvasY + pointSize >= 0 &&
                                     canvasY - pointSize <= canvas.height);

                    if (isVisible) {
                        visiblePoints++;

                        // Calculate color: Red (close) to Blue (far)
                        // normalizedDistance: 1 = closest, 0 = farthest
                        const red = Math.floor(255 * normalizedDistance);           // High when close
                        const blue = Math.floor(255 * (1 - normalizedDistance));   // High when far
                        const green = Math.floor(50 * Math.sin(normalizedDistance * Math.PI)); // Subtle green for transition

                        const color = `rgb(${red}, ${green}, ${blue})`;


                        // Draw main point
                        ctx.beginPath();
                        ctx.arc(canvasX, canvasY, pointSize, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();

                        // Add border for definition - darker for close points, lighter for far
                        const borderIntensity = 100 + 155 * normalizedDistance;
                        ctx.strokeStyle = `rgb(${borderIntensity}, ${borderIntensity}, ${borderIntensity})`;
                        ctx.lineWidth = 0.5 + normalizedDistance * 0.5;
                        ctx.stroke();
                    }
                });

                // Draw viewport boundary
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 2;
                ctx.strokeRect(0, 0, canvas.width, canvas.height);

                // Add color legend
                ctx.fillStyle = '#333';
                ctx.font = Math.max(10, maxSize * 0.02) + 'px Arial';
                ctx.fillText(`Visible: ${visiblePoints}/${totalPoints} points`, 10, canvas.height - 90);
                const lineCount = currentCollection.lines ? currentCollection.lines.length : 0;
                ctx.fillText(`Lines: ${lineCount}`, 10, canvas.height - 75);
                ctx.fillText(`Distance range from origin: ${farthestFromOrigin.toFixed(2)} - ${nearestToOrigin.toFixed(2)}`, 10, canvas.height - 60);
                ctx.fillText(`Viewpoint: (0, 0, ${viewpoint.z})`, 10, canvas.height - 45);
                ctx.fillText(`Scale: ${fixedScale.toFixed(1)}px/unit`, 10, canvas.height - 30);

                // Draw color scale legend
                ctx.fillText('Color: Red (close) â†’ Blue (far)', 10, canvas.height - 15);

                // Draw color gradient bar
                const gradientBarWidth = 100;
                const gradientBarHeight = 10;
                const gradientBarX = canvas.width - gradientBarWidth - 20;
                const gradientBarY = canvas.height - 25;

                const colorGradient = ctx.createLinearGradient(gradientBarX, 0, gradientBarX + gradientBarWidth, 0);
                colorGradient.addColorStop(0, 'rgb(0, 0, 255)');     // Blue (far)
                colorGradient.addColorStop(0.5, 'rgb(128, 25, 128)'); // Purple (middle)
                colorGradient.addColorStop(1, 'rgb(255, 0, 0)');     // Red (close)

                ctx.fillStyle = colorGradient;
                ctx.fillRect(gradientBarX, gradientBarY, gradientBarWidth, gradientBarHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.strokeRect(gradientBarX, gradientBarY, gradientBarWidth, gradientBarHeight);

                // Labels for gradient
                ctx.fillStyle = '#333';
                ctx.font = Math.max(8, maxSize * 0.015) + 'px Arial';
                ctx.fillText('Far', gradientBarX - 5, gradientBarY + 8);
                ctx.fillText('Close', gradientBarX + gradientBarWidth + 5, gradientBarY + 8);

                // Add axes labels
                ctx.font = Math.max(12, maxSize * 0.025) + 'px Arial';
                ctx.fillText('X', canvas.width - 25, canvas.height - 45);
                ctx.fillText('Y', 10, 20);
                ctx.fillText('Z (depth)', canvas.width / 2 - 30, canvas.height - 45);

                // Mark origin - this should always be at canvas center
                ctx.fillStyle = '#ff4444';
                // ctx.beginPath();
                // ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
                // ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = '#333';
                ctx.font = Math.max(10, maxSize * 0.02) + 'px Arial';
                ctx.fillText('Origin', centerX + 8, centerY - 8);

            } catch (error) {
                console.error('Error rendering 3D points:', error);
            }
        }

        function createIdentityMatrix(size) {
            const matrix = [];
            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size; j++) {
                    matrix[i][j] = (i === j) ? 1 : 0;
                }
            }
            return matrix;
        }

        function createGivensRotationMatrix(totalDimensions, dim1, dim2, piCoefficient) {
            const matrix = createIdentityMatrix(totalDimensions);

            // using pi Coefficient everywhere to avoid floating errors, using fixed precision because things that should be 0 are not 0
            const cos_angle = Number(Math.cos(piCoefficient*Math.PI).toFixed(10)) ;
            const sin_angle = Number(Math.sin(piCoefficient*Math.PI).toFixed(10)) ;

            matrix[dim1][dim1] = cos_angle;
            matrix[dim1][dim2] = -sin_angle;
            matrix[dim2][dim1] = sin_angle;
            matrix[dim2][dim2] = cos_angle;

            return matrix;
        }

        function multiplyMatrices(matrixA, matrixB) {
            const n = matrixA.length;
            const temp = [];

            for (let i = 0; i < n; i++) {
                temp[i] = [];
                for (let j = 0; j < n; j++) {
                    temp[i][j] = 0;
                    for (let k = 0; k < n; k++) {
                        temp[i][j] += matrixA[i][k] * matrixB[k][j];
                    }
                }
            }
            return temp
        }

        // Most intuitive approach: rotate around axis using Rodrigues' rotation formula concept
        function createIntuitiveAxisRotationMatrix(totalDimensions, axisIndices, piCoefficient, showDebug = false) {
            let matrix = createIdentityMatrix(totalDimensions);
            axisIndices = axisIndices.sort()// make sure we always rotate in the same order. Otherwise, the correct behaviour is to go haywire.
            axisIndices.forEach(axisIndex => {
                // For each axis, rotate all other coordinates around it
                // This creates a "barrel roll" effect around the specified axis

                // Get all dimensions except the axis
                const otherDimensions = [];
                for (let i = 0; i < totalDimensions; i++) {
                    if (i !== axisIndex) {
                        otherDimensions.push(i);
                    }
                }

                // Rotate pairs of other dimensions
                for (let i = 0; i < otherDimensions.length - 1; i += 1) {
                    for (let j = i+1; j < otherDimensions.length ; j += 1) {
                        if (i === j) {
                            continue;
                        }
                        const dim1 = otherDimensions[i];
                        const dim2 = otherDimensions[j];
                        const givensRotationMatrix = createGivensRotationMatrix(totalDimensions, dim1, dim2, piCoefficient);
                        if (showDebug){
                            console.log(`Givens rotation matrix for angle ${piCoefficient}  dimensions ${dim1} and ${dim2}:\n`, givensRotationMatrix.join('\n'));
                        }
                        matrix = multiplyMatrices(matrix, givensRotationMatrix);
                    }

                }
                if (showDebug){
                    console.log(`Matrix after rotating for angle ${piCoefficient} around axis ${axisIndex}:\n`, matrix.join('\n'));
                }
            });

            return matrix;
        }


        function multiplyPointByMatrix(point, matrix) {
            const coords = point.getCoordinates();
            const newCoords = [];

            for (let i = 0; i < coords.length; i++) {
                let sum = 0;
                for (let j = 0; j < coords.length; j++) {
                    sum += matrix[i][j] * coords[j];
                }
                newCoords[i] = sum;
            }


            return new NDimensionalPoint(...newCoords);

        }

        window.toggleRevolve = function() {
            try {
                if (!currentCollection) {
                    alert('Please generate points first!');
                    return;
                }

                const selectedDimensions = getSelectedDimensions();

                if (selectedDimensions.length === 0) {
                    alert('Please select at least one axis to rotate around!');
                    return;
                }

                if (isRevolving) {
                    // Stop revolving
                    stopRevolving();
                } else {
                    // Start revolving
                    startRevolving(selectedDimensions);
                }
            } catch (error) {
                console.error('Error in toggleRevolve:', error);
                alert('Error: ' + error.message);
            }
        }

        function startRevolving() {
//            createIntuitiveAxisRotationMatrix(baseCollection.getAllPoints()[0].getDimensions(), getSelectedDimensions(), 1/2,true);
//            createIntuitiveAxisRotationMatrix(baseCollection.getAllPoints()[0].getDimensions(), getSelectedDimensions(), 3/2,true);
            isRevolving = true;
            document.getElementById('revolveBtn').textContent = 'Stop Revolving';
            document.getElementById('revolveBtn').style.background = 'linear-gradient(145deg, #dc3545, #c82333)';
            document.getElementById('revolveBtn').style.boxShadow = '0 8px 16px rgba(220, 53, 69, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';

            // No need to calculate centroid - we're rotating around origin (0,0,0...)
            function animateRotation() {
                if (!isRevolving) return;

                try {
                    // Rotate around origin - no translation needed
                    currentCollection = rotateCollectionAroundOrigin(
                        currentCollection,
                        getSelectedDimensions(),
                        currentRotationStep
                    );
                    let distanceOfFirstPointToStart = currentCollection.getAllPoints()[0].distanceTo(baseCollection.getAllPoints()[0]);
                    // this is some exploratory code to find how many multiples of pi we need to rotate to get back to the start.  In 3d it's 2pi, but higher dimensions are more complex
                    if (distanceOfFirstPointToStart < .1) {
                        if (nearestApproach < distanceOfFirstPointToStart) {
                            nearestApproach = 1000;
                            //console.log('distance of first point ', distanceOfFirstPointToStart, '  rotation amount ', currentRotationAmount);
                        }else {
                            nearestApproach = distanceOfFirstPointToStart;
                        }
                    }
                    currentRotationAmount += currentRotationStep;

                    render3DPoints(currentCollection);
                    animationId = requestAnimationFrame(animateRotation);

                } catch (error) {
                    console.error('Error in animation:', error);
                    stopRevolving();
                }
            }

            animationId = requestAnimationFrame(animateRotation);

        }

        function stopRevolving() {
            isRevolving = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            updateRotationButtonState(); // Update button text and state
            console.log('Rotation stopped');
        }

        // Function to rotate collection around origin (no translation needed)
        function rotateCollectionAroundOrigin(collection) {
            const rotatedCollection = new PointCollection();
            for (let i = 0; i < collection.getAllPoints().length; i++) {
                const point = collection.getAllPoints()[i];
                const rotatedPoint = multiplyPointByMatrix(point, rotationMatrix);
                rotatedCollection.addPoint(rotatedPoint);
            }

            // Preserve lines from original collection
            if (collection.lines) {
                rotatedCollection.lines = collection.lines;
            }

            return rotatedCollection;
        }

        // Remove the old rotateCollectionAroundAxes function - it's no longer needed

        // Add cleanup when page is unloaded
        window.addEventListener('beforeunload', function() {
            stopRevolving();
        });

        // Optional: Add keyboard controls
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && currentCollection) {
                event.preventDefault();
                toggleRevolve();
            }
        });

        // Add window resize handler to update canvas size
        window.addEventListener('resize', function() {
            if (currentCollection && currentCollection.size() > 0) {
                render3DPoints(currentCollection);
            }
        });


        window.updateRotationSpeed = function() {
            try {
                const slider = document.getElementById('speedSlider');
                const speedDisplay = document.getElementById('speedValue');

                rotationSpeed = parseFloat(slider.value);
                currentRotationStep = BASE_ROTATION_STEP * rotationSpeed;
                speedDisplay.textContent = rotationSpeed.toFixed(1) + 'x';
                nearestApproach = 1000;
                rotationMatrix = createIntuitiveAxisRotationMatrix(
                        currentCollection.getAllPoints()[0].getDimensions(),
                        getSelectedDimensions(),
                        currentRotationStep
                );

            } catch (error) {
                console.error('Error updating rotation speed:', error);
            }
        }

        window.updateZoom = function() {
            try {
                const slider = document.getElementById('zoomSlider');
                const valueDisplay = document.getElementById('zoomValue');

                const zoomLevel = parseFloat(slider.value);
                valueDisplay.textContent = zoomLevel.toFixed(2);

                // Re-render with new zoom
                if (currentCollection && currentCollection.size() > 0) {
                    render3DPoints(currentCollection);
                }

                console.log('Zoom level updated to:', zoomLevel);
            } catch (error) {
                console.error('Error updating zoom:', error);
            }
        }

        // Generate points within unit n-dimensional sphere using rejection sampling
        function generatePointsInUnitSphere(numPoints, dimensions) {
            let pointsGenerated = 0;
            let attempts = 0;
            currentCollection.clear();
            const maxAttempts = numPoints * 100; // Prevent infinite loops

            while (pointsGenerated < numPoints && attempts < maxAttempts) {
                attempts++;

                // Generate random coordinates in [-1, 1] range
                const coordinates = [];
                for (let i = 0; i < dimensions; i++) {
                    coordinates.push((Math.random() - 0.5) * 2); // Random between -1 and 1
                }

                // Create point and check if it's within unit distance
                const point = new NDimensionalPoint(...coordinates);
                const distanceFromOrigin = point.magnitude(); // This calculates Euclidean distance from origin

                if (distanceFromOrigin <= 1.0) {
                    currentCollection.addPoint(point);
                    pointsGenerated++;
                }
            }

            if (pointsGenerated < numPoints) {
                console.warn(`Only generated ${pointsGenerated} out of ${numPoints} requested points after ${maxAttempts} attempts`);
                console.warn(`This can happen in high dimensions where the unit sphere occupies a very small fraction of the unit cube`);
            }
//            add the origin here so it's rendered with the rest of the points
            const originCoordinates = [];
            for (let i = 0; i < dimensions; i++) {
                originCoordinates.push(0);
            }
            currentCollection.addPoint(new NDimensionalPoint(...originCoordinates));

            console.log(`Generated ${pointsGenerated} points in ${attempts} attempts (${(pointsGenerated/attempts*100).toFixed(2)}% success rate)`);
        }

        // Function called when dimension checkbox is changed
        function onDimensionCheckboxChange() {

            // Get dimension name for logging
            // let dimensionName;
            // if (dimensionIndex === 0) dimensionName = 'X';
            // else if (dimensionIndex === 1) dimensionName = 'Y';
            // else if (dimensionIndex === 2) dimensionName = 'Z';
            // else dimensionName = `W${dimensionIndex-2}`;

            // Get all currently selected dimensions
            const selectedDimensions = getSelectedDimensions();

            // Update rotation if currently rotating
            if (isRevolving) {
                updateActiveRotation(selectedDimensions);
            }
            baseCollection = currentCollection.copy();
            currentRotationAmount = 0;
            nearestApproach = 1000;
            rotationMatrix = createIntuitiveAxisRotationMatrix(
                    currentCollection.getAllPoints()[0].getDimensions(),
                    getSelectedDimensions(),
                    currentRotationStep
            );


            // Update UI state
            updateRotationButtonState();
        }

        // Get all currently selected dimension indices
        function getSelectedDimensions() {
            const selectedDimensions = [];
            const checkboxes = document.querySelectorAll('#checkboxContainer input[type="checkbox"]:checked');

            checkboxes.forEach(checkbox => {
                selectedDimensions.push(parseInt(checkbox.value));
            });

            return selectedDimensions.sort((a, b) => a - b); // Sort for consistency
        }

        // Update the rotation button state based on selected dimensions
        function updateRotationButtonState() {
            const revolveBtn = document.getElementById('revolveBtn');
            const selectedDimensions = getSelectedDimensions();

            if (selectedDimensions.length === 0) {
                revolveBtn.disabled = true;
                revolveBtn.textContent = 'Select Axes to Rotate';
                revolveBtn.style.background = 'linear-gradient(145deg, #ccc, #aaa)';
                revolveBtn.style.cursor = 'not-allowed';
                revolveBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';
            } else {
                revolveBtn.disabled = false;
                revolveBtn.style.cursor = 'pointer';

                if (isRevolving) {
                    revolveBtn.textContent = 'Stop Revolving';
                    revolveBtn.style.background = 'linear-gradient(145deg, #dc3545, #c82333)';
                    revolveBtn.style.boxShadow = '0 8px 16px rgba(220, 53, 69, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';
                } else {
                    const axesNames = selectedDimensions.map(dim => {
                        if (dim === 0) return 'X';
                        if (dim === 1) return 'Y';
                        if (dim === 2) return 'Z';
                        return `W${dim-2}`;
                    }).join(', ');
                    revolveBtn.textContent = `Rotate around ${axesNames}`;
                    revolveBtn.style.background = 'linear-gradient(145deg, #4a90e2, #357abd)';
                    revolveBtn.style.boxShadow = '0 8px 16px rgba(74, 144, 226, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';
                }
            }
        }

        // Update active rotation with new dimension selection
        function updateActiveRotation(selectedDimensions) {
            if (selectedDimensions.length === 0) {
                console.log('No dimensions selected - stopping rotation');
                stopRevolving();
                return;
            }

            // The rotation will automatically use the new selected dimensions
            // on the next animation frame since startRevolving reads from checkboxes
            console.log('Rotation will continue with new axes:', selectedDimensions);
        }

        // Add current position to each point's trail
        function updateTrails(points3D) {
            const showTrails = document.getElementById('showTrails').checked;
            if (!showTrails) return;

            // Get current zoom and canvas settings
            const canvas = document.getElementById('canvas3d');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomLevel = zoomSlider ? parseFloat(zoomSlider.value) : 0.15;
            const fixedScale = Math.min(canvas.width, canvas.height) * zoomLevel;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;


            points3D.forEach((point, index) => {
                const canvasX = centerX + (point.x * fixedScale);
                const canvasY = centerY + (point.y * fixedScale);

                // Get or create trail for this point
                if (!pointTrails.has(index)) {
                    pointTrails.set(index, []);
                }

                const trail = pointTrails.get(index);

                // Add current position to trail
                trail.push({
                    x: canvasX,
                    y: canvasY,
                    timestamp: Date.now(),
                    distance: point.distanceFromViewpoint
                });

                // Limit trail length
                if (trail.length > maxTrailLength) {
                    trail.shift(); // Remove oldest point
                }
            });
        }


        // Draw trails for all points
        function drawTrails(ctx) {
            const showTrails = document.getElementById('showTrails').checked;
            if (!showTrails || pointTrails.size === 0) return;

            const canvas = document.getElementById('canvas3d');

            pointTrails.forEach((trail) => {
                if (trail.length < 2) return; // Need at least 2 points to draw a trail

                // Draw trail as connected line segments with fading
                for (let i = 1; i < trail.length; i++) {
                    const prevPoint = trail[i - 1];
                    const currentPoint = trail[i];

                    // Calculate fade based on position in trail (newer = more opaque)
                    const fadeRatio = i / trail.length;
                    const opacity = fadeRatio * 0.8; // Max opacity of 0.8

                    // Calculate color based on distance (same as main points)
                    const distances = trail.map(p => p.distance);
                    const minDistance = Math.min(...distances);
                    const maxDistance = Math.max(...distances);
                    const distanceRange = maxDistance - minDistance || 1;

                    const normalizedDistance = distanceRange > 0 ?
                            1 - ((currentPoint.distance - minDistance) / distanceRange) : 0.5;

                    const red = Math.floor(255 * normalizedDistance);
                    const blue = Math.floor(255 * (1 - normalizedDistance));
                    const green = Math.floor(50 * Math.sin(normalizedDistance * Math.PI));

                    // Only draw if both points are reasonably close to viewport
                    const margin = 100; // Allow some off-screen drawing
                    if (currentPoint.x >= -margin && currentPoint.x <= canvas.width + margin &&
                            currentPoint.y >= -margin && currentPoint.y <= canvas.height + margin) {

                        ctx.beginPath();
                        ctx.moveTo(prevPoint.x, prevPoint.y);
                        ctx.lineTo(currentPoint.x, currentPoint.y);

                        ctx.strokeStyle = `rgba(${red}, ${green}, ${blue}, ${opacity})`;
                        ctx.lineWidth = 1 + fadeRatio; // Thicker lines for newer trail segments
                        ctx.stroke();
                    }
                }

                // Draw small dots at trail points for better visibility
                trail.forEach((trailPoint, i) => {
                    if (i % 3 !== 0) return; // Only draw every 3rd point to avoid clutter

                    const fadeRatio = i / trail.length;
                    const opacity = fadeRatio * 0.6;

                    if (opacity > 0.1) { // Only draw if reasonably visible

                        ctx.beginPath();
                        ctx.arc(trailPoint.x, trailPoint.y, 1, 0, 2 * Math.PI);
                        ctx.fillStyle = `rgba(128, 128, 128, ${opacity})`;
                        ctx.fill();
                    }
                });
            });
        }

        function drawLines(ctx, points3D) {
            if (!currentCollection || !currentCollection.lines || currentCollection.lines.length === 0) {
                return;
            }

            const canvas = document.getElementById('canvas3d');
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomLevel = zoomSlider ? parseFloat(zoomSlider.value) : 0.15;
            const fixedScale = Math.min(canvas.width, canvas.height) * zoomLevel;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw lines
            currentCollection.lines.forEach(line => {
 //               console.log("Drawing line:", line);
                const startIndex = line[0];
                const endIndex = line[1];

                if (startIndex < points3D.length && endIndex < points3D.length) {
                    const startPoint = points3D[startIndex];
                    const endPoint = points3D[endIndex];

                    const startX = centerX + (startPoint.x * fixedScale);
                    const startY = centerY + (startPoint.y * fixedScale);
                    const endX = centerX + (endPoint.x * fixedScale);
                    const endY = centerY + (endPoint.y * fixedScale);

                    // Calculate line color based on average distance of endpoints
                    const avgDistance = (startPoint.distanceFromViewpoint + endPoint.distanceFromViewpoint) / 2;
                    const distances = points3D.map(p => p.distanceFromViewpoint);
                    const minDistance = Math.min(...distances);
                    const maxDistance = Math.max(...distances);
                    const distanceRange = maxDistance - minDistance || 1;

                    const normalizedDistance = distanceRange > 0 ?
                        1 - ((avgDistance - minDistance) / distanceRange) : 0.5;

                    const red = Math.floor(128 + 127 * normalizedDistance);
                    const blue = Math.floor(128 + 127 * (1 - normalizedDistance));
                    const green = Math.floor(64);

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = `rgba(${red}, ${green}, ${blue}, 0.7)`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            });
        }

        window.updateTrailLength = function() {
            try {
                const slider = document.getElementById('trailLengthSlider');
                const valueDisplay = document.getElementById('trailLengthValue');

                maxTrailLength = parseInt(slider.value);
                valueDisplay.textContent = maxTrailLength.toString();

                // Trim existing trails to new length if they're longer
                pointTrails.forEach((trail) => {
                    if (trail.length > maxTrailLength) {
                        trail.splice(0, trail.length - maxTrailLength);
                    }
                });

                console.log('Trail length updated to:', maxTrailLength);
            } catch (error) {
                console.error('Error updating trail length:', error);
            }
        }

        // Add this function after the generatePointsInUnitSphere function
        function generateTesseract() {
            try {
                if (!NDimensionalPoint || !PointCollection) {
                    alert('JavaScript modules not loaded properly');
                    return;
                }

                // Create PointCollection and clear previous data
                currentCollection = new PointCollection();
                pointTrails = new Map(); // Clear previous trails

                // Generate tesseract vertices (4D cube with vertices at Â±1 for each dimension)
                const vertices = [];
                for (let i = 0; i < 16; i++) {
                    const coords = [
                        (i & 1) ? 1 : -1,        // x coordinate
                        (i & 2) ? 1 : -1,        // y coordinate
                        (i & 4) ? 1 : -1,        // z coordinate
                        (i & 8) ? 1 : -1         // w coordinate
                    ];
                    vertices.push(new NDimensionalPoint(...coords));
                    currentCollection.addPoint(new NDimensionalPoint(...coords));
                }

                // Generate tesseract edges
                // In a tesseract, two vertices are connected if they differ in exactly one coordinate
                const lines = [];
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        // Count how many coordinates differ
                        //let distanceBetweenPoints = currentCollection.points[i].distanceTo(currentCollection.points[j]);
                        let diffCount = 0;
                        if ((i & 1) !== (j & 1)) diffCount++;
                        if ((i & 2) !== (j & 2)) diffCount++;
                        if ((i & 4) !== (j & 4)) diffCount++;
                        if ((i & 8) !== (j & 8)) diffCount++;
                        //console.log(distanceBetweenPoints, '  distance, diff ', diffCount);
                        // Connect vertices that differ in exactly one coordinate
                        if (diffCount === 1) {
                            lines.push([i, j]);
                        }
                    }
                }

                // Add lines to collection
                currentCollection.lines = lines;

                // Add origin point for reference
                currentCollection.addPoint(new NDimensionalPoint(0, 0, 0, 0));

                // Set dimensions input to 4
                document.getElementById('numDimensions').value = 4;
                document.getElementById('numPoints').value = 16;

                // Show dimension checkboxes
                updateDimensionCheckboxes();
                document.getElementById('dimensionCheckboxes').style.display = 'block';

                // Show and render 3D visualization
                document.getElementById('canvasContainer').style.display = 'block';
                render3DPoints(currentCollection);

                alert(`Successfully generated tesseract with 16 vertices and ${lines.length} edges!`);
            } catch (error) {
                console.error('Error in generateTesseract:', error);
                alert('Error generating tesseract: ' + error.message);
            }
        }

        window.generateTesseract = generateTesseract;
    </script>
</body>
</html>
