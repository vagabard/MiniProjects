<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Point Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            /*max-width: 600px;*/
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .input-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }

        .input-row .input-group {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #007bff;
        }

        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            font-size: 16px;
            cursor: pointer;
            width: auto;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #0056b3;
        }

        /*button.stop-button {*/
        /*    background-color: #dc3545;*/
        /*}*/

        /*button.stop-button:hover {*/
        /*    background-color: #c82333;*/
        /*}*/

        .animation-info {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .checkbox-item {
            display: inline-block;
            margin: 5px 10px;
            white-space: nowrap;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 5px;
            transform: scale(1.2);
        }

        .checkbox-item label {
            cursor: pointer;
            user-select: none;
            font-weight: normal;
            margin-bottom: 0;
        }

        .checkbox-item input[type="checkbox"]:checked + label {
            color: #007bff;
            font-weight: bold;
        }

        #revolveBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed !important;
            background: linear-gradient(145deg, #ccc, #aaa) !important;
            transform: none !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:hover:not(:disabled) {
            transform: translateY(-3px);
        }

        #revolveBtn:hover:not(:disabled)[style*="linear-gradient(145deg, #4a90e2"] {
            background: linear-gradient(145deg, #5ba0f2, #4080cd) !important;
            box-shadow: 0 12px 24px rgba(74, 144, 226, 0.5), 0 6px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:hover:not(:disabled)[style*="linear-gradient(145deg, #dc3545"] {
            background: linear-gradient(145deg, #e74c3c, #d63031) !important;
            box-shadow: 0 12px 24px rgba(220, 53, 69, 0.5), 0 6px 12px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4), inset 0 -1px 0 rgba(0, 0, 0, 0.2) !important;
        }

        #revolveBtn:active:not(:disabled) {
            transform: translateY(-1px);
        }

        #revolveBtn:active:not(:disabled)[style*="linear-gradient(145deg, #4a90e2"] {
            box-shadow: 0 4px 8px rgba(74, 144, 226, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.3) !important;
        }

        #revolveBtn:active:not(:disabled)[style*="linear-gradient(145deg, #dc3545"] {
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3), 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.2), inset 0 -1px 0 rgba(0, 0, 0, 0.3) !important;
        }

        #dimensionCheckboxes {
            border-top: 1px solid #ddd;
            padding-top: 20px;
            margin-top: 20px;
            display: inline-block;
        }

        #checkboxContainer {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
            margin: 10px 0;
            justify-content: flex-start;
            align-items: center;
        }

        #canvas3d {
            border: 2px solid #ddd;
            margin-top: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: auto;
            margin-right: auto;
            width: 100%;
            height: auto;
            box-sizing: border-box;
        }

        #canvas3d canvas {
            display: block;
        }

        #canvasContainer {
            text-align: center;
            margin: 20px auto;
            width: 100%;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .controls-row label {
            margin-bottom: 0;
            font-weight: normal;
        }

        #speedSlider {
            width: 150px;
            padding: 0;
        }

        #speedValue {
            font-weight: bold;
            color: #007bff;
            min-width: 40px;
        }

        /* Make container responsive */
        @media (max-width: 600px) {
            .controls-row {
                flex-direction: column;
                gap: 5px;
            }

            #speedSlider {
                width: 200px;
            }

            .input-row {
                flex-direction: column;
                gap: 10px;
            }
        }

        .button-row {
            display: flex;
            gap: 15px;
            margin-top: 10px;
        }

        /* Main container for input boxes and generate/tesseract buttons */
        .input-and-buttons-container {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-bottom: 20px;
        }

        /* Responsive controls container */
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
            align-items: flex-start;
        }

        .controls-container .button-row {
            margin-top: 0;
            flex: 1;
            min-width: 300px;
        }

        .controls-container #dimensionCheckboxes {
            flex: 1;
            min-width: 250px;
            margin-top: 0;
        }

        .controls-container #dimensionCheckboxes #revolveBtn {
            margin-top: 10px;
        }

        #visualizationControls {
            border-top: 1px solid #ddd;
            padding-top: 20px;
            margin-top: 20px;
            background-color: #f9f9f9;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }

        #visualizationControls .controls-row {
            margin-bottom: 10px;
            gap: 5px;
        }

        #visualizationControls .controls-row label {
            min-width: 50px;
            font-size: 14px;
        }

        #visualizationControls input[type="range"] {
            width: auto;
        }

        #visualizationControls span {
            min-width: 35px;
            font-size: 12px;
        }

        /* On smaller screens, stack vertically */
        @media (max-width: 800px) {
            .controls-container {
                flex-direction: column;
            }

            .controls-container .button-row,
            .controls-container #dimensionCheckboxes,
            .controls-container #visualizationControls {
                min-width: 100%;
            }
        }

        .button-row button {
            flex: 1;
            background: linear-gradient(145deg, #4a90e2, #357abd);
            color: white;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            position: relative;

            /* 3D effect */
            box-shadow:
                0 8px 16px rgba(74, 144, 226, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);

            border-top: 1px solid rgba(255, 255, 255, 0.4);
            border-bottom: 2px solid rgba(0, 0, 0, 0.3);
        }

        .button-row button:hover {
            background: linear-gradient(145deg, #5ba0f2, #4080cd);
            transform: translateY(-3px);
            box-shadow:
                0 12px 24px rgba(74, 144, 226, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:active {
            transform: translateY(-1px);
            box-shadow:
                0 4px 8px rgba(74, 144, 226, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }

        .button-row button:nth-child(2) {
            background: linear-gradient(145deg, #5cb85c, #449d44);
            box-shadow:
                0 8px 16px rgba(92, 184, 92, 0.4),
                0 4px 8px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:nth-child(2):hover {
            background: linear-gradient(145deg, #6cc86c, #559d55);
            box-shadow:
                0 12px 24px rgba(92, 184, 92, 0.5),
                0 6px 12px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -1px 0 rgba(0, 0, 0, 0.2);
        }

        .button-row button:nth-child(2):active {
            box-shadow:
                0 4px 8px rgba(92, 184, 92, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>n Dimensional rotation</h2>
        <form>
            <div class="input-and-buttons-container">
                <div class="input-row">
                    <div class="input-group">
                        <label for="numPoints">Specify number of points:</label>
                        <input type="number" id="numPoints" name="numPoints" min="1" placeholder="Enter number of points">
                    </div>
                    <div class="input-group">
                        <label for="numDimensions">Specify number of dimensions:</label>
                        <input type="number" id="numDimensions" name="numDimensions" min="1" placeholder="Enter number of dimensions" onchange="updateDimensionCheckboxes()">
                    </div>
                </div>
                <div class="button-row">
                    <button type="button" onclick="generatePoints()">Generate Random Points</button>
                    <button type="button" onclick="generateTesseract()">Generate N-Dimensional Cube</button>
                </div>
            </div>

            <div class="controls-container">
                <div id="dimensionCheckboxes" class="form-group" style="display: none;">
                    <label>Select axes to rotate around:</label>
                    <div id="checkboxContainer"></div>
                    <button type="button" id="revolveBtn" onclick="toggleRevolve()" style="margin-top: 10px; background: linear-gradient(145deg, #4a90e2, #357abd); color: white; padding: 16px 24px; border: none; border-radius: 12px; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.2s ease; text-transform: uppercase; letter-spacing: 0.8px; position: relative; box-shadow: 0 8px 16px rgba(74, 144, 226, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2); border-top: 1px solid rgba(255, 255, 255, 0.4); border-bottom: 2px solid rgba(0, 0, 0, 0.3);">Start Revolving</button>
                    <div class="animation-info">Tip: Press spacebar to start/stop rotation</div>
                </div>
                <div id="visualizationControls" class="form-group" style="display: none;">
                    <label>3D Visualization Controls:</label>
                    <div class="controls-row">
                        <label for="speedSlider">Speed:</label>
                        <input type="range" id="speedSlider" min="0" max="2" step="0.01" value="1" oninput="updateRotationSpeed()">
                        <span id="speedValue">1.0x</span>
                    </div>
                    <div class="controls-row">
                        <label for="zoomSlider">Zoom:</label>
                        <input type="range" id="zoomSlider" min="0.05" max="1" step="0.01" value="0.5" oninput="updateZoom()">
                        <span id="zoomValue">0.15</span>
                    </div>
                    <div class="controls-row">
                        <label for="trailLengthSlider">Trail:</label>
                        <input type="range" id="trailLengthSlider" min="10" max="500" step="10" value="150" oninput="updateTrailLength()">
                        <span id="trailLengthValue">150</span>
                    </div>
                    <div class="controls-row">
                        <label for="showTrails">Show trails:</label>
                        <input type="checkbox" id="showTrails">
                    </div>
                </div>
            </div>
        </form>
    </div>
    <div id="canvasContainer" style="display: none;">
        <h3>3D Visualization</h3>
        <div id="canvas3d"></div>
        <p><small>Points sized by depth: closer = larger, farther = smaller</small></p>
    </div>
    <script type="module">
        let NDimensionalPoint, PointCollection, currentCollection ;

        // Animation variables
        let isRevolving = false;
        let animationId = null;
        let maxDrawingSize = .05;
        let minDrawingSize = .005;
        const BASE_ROTATION_STEP = 1 / 180; // 0.5 degrees in radians
        let rotationSpeed = 1.0; // Speed multiplier
        let currentRotationStep = BASE_ROTATION_STEP;
        let currentRotationAmount = 0;
        let baseCollection ;
        let rotationMatrix;
        // Trail system variables
        let pointTrails = new Map(); // Store trails for each point
        let maxTrailLength = 150; // Maximum number of trail points to keep (adjustable by user)
        let nearestApproach = 1000;

        // Three.js variables
        let scene, camera, renderer;
        let pointMeshes = [];
        let lineMeshes = [];
        let trailMeshes = [];
        let containerSize = 800;
        // Load modules with error handling
        try {
            console.log('Loading NDimensionalPoint.js...');
            const ndPointModule = await import('./NDimensionalPoint.js');
            console.log('NDimensionalPoint.js loaded successfully');

            console.log('Loading PointCollection.js...');
            const collectionModule = await import('./PointCollection.js');
            console.log('PointCollection.js loaded successfully');

            NDimensionalPoint = ndPointModule.default;
            PointCollection = collectionModule.default;
            console.log('Modules loaded successfully');
        } catch (error) {
            console.error('Error loading modules:', error);
            console.error('Error details:', error.message);
            console.error('Error stack:', error.stack);
            alert(`Error loading JavaScript modules: ${error.message}\n\nMake sure NDimensionalPoint.js and PointCollection.js exist in the same directory.`);
        }

        window.generatePoints = function() {
            try {
                const numPoints = document.getElementById('numPoints').value;
                const numDimensions = document.getElementById('numDimensions').value;

                if (!numPoints || numPoints < 1) {
                    alert('Please enter a valid number of points (1 or greater)');
                    return;
                }

                if (!numDimensions || numDimensions < 3) {
                    alert('Please enter at least 3 dimensions for 3D visualization');
                    return;
                }

                if (!NDimensionalPoint || !PointCollection) {
                    alert('JavaScript modules not loaded properly');
                    return;
                }

                // Create PointCollection and generate points within unit sphere
                currentCollection = new PointCollection();
                pointTrails = new Map(); // Clear previous trails
                generatePointsInUnitSphere(parseInt(numPoints), parseInt(numDimensions));

                // Show dimension checkboxes
                updateDimensionCheckboxes();
                document.getElementById('dimensionCheckboxes').style.display = 'block';

                // Show and render 3D visualization
                document.getElementById('canvasContainer').style.display = 'block';
                document.getElementById('visualizationControls').style.display = 'block';
                render3DPoints(currentCollection);

                alert(`Successfully generated ${numPoints} points with ${numDimensions} dimensions within unit distance of origin!`);
            } catch (error) {
                console.error('Error in generatePoints:', error);
                alert('Error generating points: ' + error.message);
            }
        }

        window.updateDimensionCheckboxes = function() {
            try {
                const numDimensions = document.getElementById('numDimensions').value;
                const container = document.getElementById('checkboxContainer');

                if (!container) {
                    console.error('Checkbox container not found');
                    return;
                }

                if (!numDimensions || numDimensions < 1) {
                    container.innerHTML = '';
                    document.getElementById('dimensionCheckboxes').style.display = 'none';
                    return;
                }

                container.innerHTML = '';

                for (let i = 0; i < parseInt(numDimensions); i++) {
                    const checkboxItem = document.createElement('div');
                    checkboxItem.className = 'checkbox-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `dim${i}`;
                    checkbox.value = i.toString();

                    // Add event listener to detect changes
                    checkbox.addEventListener('change', function(event) {
                        onDimensionCheckboxChange(i, event.target.checked);
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `dim${i}`;

                    // Label dimensions: x, y, z, then w with subscripts
                    if (i === 0) {
                        label.textContent = 'x';
                    } else if (i === 1) {
                        label.textContent = 'y';
                    } else if (i === 2) {
                        label.textContent = 'z';
                    } else {
                        label.innerHTML = `w<sub>${i-2}</sub>`;
                    }

                    checkboxItem.appendChild(checkbox);
                    checkboxItem.appendChild(label);
                    container.appendChild(checkboxItem);
                }
            } catch (error) {
                console.error('Error updating checkboxes:', error);
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas3d');
            const containerElement = document.getElementById('canvasContainer');
            const containerWidth = containerElement.clientWidth;

            // Calculate available height (window height minus other elements)
            const windowHeight = window.innerHeight;
            const containerTop = container.getBoundingClientRect().top;
            const availableHeight = windowHeight - containerTop - 20; // 20px for bottom margin

            // Use the smaller of available width or height to maintain square aspect ratio
            // Width accounts for 40px total padding (20px each side), height uses smaller margin
            containerSize = Math.min(containerWidth - 40, availableHeight);

            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(0, 0, 3);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(containerSize, containerSize);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Clear container and add renderer
            container.innerHTML = '';
            container.appendChild(renderer.domElement);

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            // directionalLight.position.set(10, 10, 5);
            // directionalLight.castShadow = true;
            // scene.add(directionalLight);
            // window.addEventListener('resize', onWindowResized)
            // onWindowResized();
            return containerSize;
        }

        // function onWindowResized() {
        //     camera.aspect = window.innerWidth / window.innerHeight;
        //     camera.updateProjectionMatrix();
        //     renderer.setSize(window.innerWidth, window.innerHeight);
        // }

        function getViewpoint(){
            // Define viewpoint position (camera position) - get from slider
            const viewpointSlider = document.getElementById('viewpointZ');
            const viewpointDistance = viewpointSlider ? parseFloat(viewpointSlider.value) : 3;

            return {
                x: 0,    // Centered on X
                y: 0,    // Centered on Y
                z: viewpointDistance     // Distance from slider
            };

        }

        function trimNDimensionalPointTo3d(collectionOfPoints, viewpoint) {
            return collectionOfPoints.map(point => {
                const x = point.getCoordinate(0);
                const y = point.getCoordinate(1);
                const z = point.getCoordinate(2);

                // Calculate distance from viewpoint using 3D Euclidean distance
                const distanceFromViewpoint = Math.sqrt(
                        Math.pow(x - viewpoint.x, 2) +
                        Math.pow(y - viewpoint.y, 2) +
                        Math.pow(z - viewpoint.z, 2)
                );
                const distanceToOrigin = Math.sqrt(x * x + y * y + z * z);

                return {
                    x: x,
                    y: y,
                    z: z,
                    distanceFromViewpoint: distanceFromViewpoint,
                    distanceToOrigin: distanceToOrigin,
                    originalPoint: point
                };
            });
        }

         // 3D rendering functions
        function render3DPoints(currentCollection) {
            try {
                if (!currentCollection || currentCollection.size() === 0) {
                    return;
                }

                // Initialize Three.js if not already done
                if (!scene) {
                    initThreeJS();
                }

                // Clear previous meshes
                clearPreviousMeshes();

                const points = currentCollection.getAllPoints();
                const viewpoint = getViewpoint();
                const points3D = trimNDimensionalPointTo3d(points, viewpoint);

                // Update trails with current positions
                updateTrails(points3D);

                // Get zoom level from slider
                const zoomSlider = document.getElementById('zoomSlider');
                const zoomLevel = zoomSlider ? parseFloat(zoomSlider.value) : 0.5;

                // Update camera position based on viewpoint
                camera.position.set(0, 0, viewpoint.z);

                // Find min/max distances for normalization
                const distances = points3D.slice(0,-1).map(p => p.distanceToOrigin);
                const farthestFromOrigin = Math.max(...distances);
                const nearestToOrigin = Math.min(...distances);
                const minDistance = viewpoint.z - farthestFromOrigin;
                const maxDistance = viewpoint.z + farthestFromOrigin;
                const distanceRange = maxDistance - minDistance;

                // Create points
                points3D.forEach((point, index) => {
                    // Skip origin point for special rendering
                    if (point.x === 0 && point.y === 0 && point.z === 0) {
                        createOriginPoint();
                        return;
                    }

                    const normalizedDistance = distanceRange > 0 ? 
                        (distanceRange - (point.distanceFromViewpoint - minDistance)) / distanceRange : 0.5;

                    // Calculate point size
                    const minPointSize = minDrawingSize;
                    const dimensions = currentCollection.getAllPoints()[0].getDimensions();
                    let maxPointSize = maxDrawingSize;
                    if (dimensions > 4) {
                        maxPointSize = Math.max(maxDrawingSize * 4 / dimensions, minDrawingSize);
                    }
                    const pointSize = minPointSize + normalizedDistance * (maxPointSize - minPointSize);

                    // Calculate color: Red (close) to Blue (far)
                    const red = normalizedDistance;
                    const blue = 1 - normalizedDistance;
                    const green = 0.2 * Math.sin(normalizedDistance * Math.PI);

                    createPointMesh(point.x * zoomLevel, point.y * zoomLevel, point.z * zoomLevel, 
                                  pointSize, new THREE.Color(red, green, blue));
                });

                // Create lines
                createLines(points3D, currentCollection.lines, zoomLevel, distanceRange, minDistance);

                // Create trails
                createTrails();

                // Add coordinate axes
                createCoordinateAxes();

                // Render the scene
                renderer.render(scene, camera);

            } catch (error) {
                console.error('Error rendering 3D points:', error);
            }
        }

        function clearPreviousMeshes() {
            // Remove all point meshes
            pointMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            pointMeshes = [];

            // Remove all line meshes
            lineMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            lineMeshes = [];

            // Remove all trail meshes
            trailMeshes.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            trailMeshes = [];
        }

        function createPointMesh(x, y, z, size, color) {
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            pointMeshes.push(mesh);
        }

        function createOriginPoint() {
            const geometry = new THREE.SphereGeometry(0.03, 16, 16);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0, 0);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            pointMeshes.push(mesh);
        }

        function createLines(points3D, lines, zoomLevel, distanceRange, minDistance) {
            if (!lines || lines.length === 0) return;

            lines.forEach(line => {
                const startIndex = line[0];
                const endIndex = line[1];

                if (startIndex < points3D.length && endIndex < points3D.length) {
                    const startPoint = points3D[startIndex];
                    const endPoint = points3D[endIndex];

                    // Calculate normalized distances for both endpoints
                    const startNormalizedDistance = distanceRange > 0 ? 
                        (distanceRange - (startPoint.distanceFromViewpoint - minDistance)) / distanceRange : 0.5;
                    const endNormalizedDistance = distanceRange > 0 ? 
                        (distanceRange - (endPoint.distanceFromViewpoint - minDistance)) / distanceRange : 0.5;

                    // Calculate point sizes using same logic as points
                    const minPointSize = minDrawingSize;
                    const dimensions = points3D[0].originalPoint.getDimensions();
                    let maxPointSize = maxDrawingSize;
                    if (dimensions > 4) {
                        maxPointSize = Math.max(maxDrawingSize * 4 / dimensions, minDrawingSize);
                    }
                    const startRadius = minPointSize + startNormalizedDistance * (maxPointSize - minPointSize);
                    const endRadius = minPointSize + endNormalizedDistance * (maxPointSize - minPointSize);

                    // Calculate line color based on average distance of endpoints
                    const avgDistance = (startPoint.distanceFromViewpoint + endPoint.distanceFromViewpoint) / 2;
                    const avgNormalizedDistance = distanceRange > 0 ?
                        1 - ((avgDistance - minDistance) / distanceRange) : 0.5;

                    const red = 0.5 + 0.5 * avgNormalizedDistance;
                    const blue = 0.5 + 0.5 * (1 - avgNormalizedDistance);
                    const green = 0.25;

                    // Create 3D cylindrical line with tapering
                    create3DLine(
                        new THREE.Vector3(startPoint.x * zoomLevel, startPoint.y * zoomLevel, startPoint.z * zoomLevel),
                        new THREE.Vector3(endPoint.x * zoomLevel, endPoint.y * zoomLevel, endPoint.z * zoomLevel),
                        startRadius,
                        endRadius,
                        new THREE.Color(red, green, blue)
                    );
                }
            });
        }

        function create3DLine(startPos, endPos, startRadius, endRadius, color) {
            // Calculate line direction and length
            const direction = new THREE.Vector3().subVectors(endPos, startPos);
            const length = direction.length();

            if (length === 0) return; // Skip zero-length lines

            direction.normalize();

            // Create tapered cylinder geometry
            const segments = 8; // Number of radial segments
            const heightSegments = 16; // Number of height segments for smooth tapering

            // Create custom geometry for tapered cylinder
            const geometry = new THREE.CylinderGeometry(endRadius, startRadius, length, segments, heightSegments);

            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                opacity: 1,
                transparent: false
            });

            const lineMesh = new THREE.Mesh(geometry, material);

            // Position and orient the cylinder
            const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
            lineMesh.position.copy(midPoint);

            // Orient the cylinder along the line direction
            // Default cylinder is along Y-axis, so we need to rotate it
            const up = new THREE.Vector3(0, 1, 0);
            const quaternion = new THREE.Quaternion().setFromUnitVectors(up, direction);
            lineMesh.setRotationFromQuaternion(quaternion);

            lineMesh.castShadow = true;
            lineMesh.receiveShadow = true;
            scene.add(lineMesh);
            lineMeshes.push(lineMesh);
        }

        function createCoordinateAxes() {
            // X axis (red)
            const xGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(1, 0, 0)
            ]);
            const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, opacity: 0.3, transparent: true });
            const xLine = new THREE.Line(xGeometry, xMaterial);
            scene.add(xLine);
            lineMeshes.push(xLine);

            // Y axis (green)
            const yGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 1, 0)
            ]);
            const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, opacity: 0.3, transparent: true });
            const yLine = new THREE.Line(yGeometry, yMaterial);
            scene.add(yLine);
            lineMeshes.push(yLine);

            // Z axis (blue)
            const zGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(0, 0, -1),
                new THREE.Vector3(0, 0, 1)
            ]);
            const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, opacity: 0.3, transparent: true });
            const zLine = new THREE.Line(zGeometry, zMaterial);
            scene.add(zLine);
            lineMeshes.push(zLine);
        }

        function createTrails() {
            const showTrails = document.getElementById('showTrails').checked;
            if (!showTrails || pointTrails.size === 0) return;

            pointTrails.forEach((trail) => {
                if (trail.length < 2) return;

                const points = [];
                const colors = [];

                for (let i = 0; i < trail.length; i++) {
                    const trailPoint = trail[i];
                    // Use the stored 3D coordinates directly
                    points.push(new THREE.Vector3(trailPoint.x, trailPoint.y, trailPoint.z));

                    // Calculate fade based on position in trail
                    const fadeRatio = i / trail.length;

                    // Calculate color based on distance
                    const distances = trail.map(p => p.distance);
                    const minDistance = Math.min(...distances);
                    const maxDistance = Math.max(...distances);
                    const distanceRange = maxDistance - minDistance || 1;

                    const normalizedDistance = distanceRange > 0 ?
                        1 - ((trailPoint.distance - minDistance) / distanceRange) : 0.5;

                    const red = normalizedDistance;
                    const blue = 1 - normalizedDistance;
                    const green = 0.2 * Math.sin(normalizedDistance * Math.PI);

                    colors.push(red, green, blue);
                }

                if (points.length > 1) {
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                    const material = new THREE.LineBasicMaterial({ 
                        vertexColors: true,
                        opacity: 0.6,
                        transparent: true
                    });

                    const trailMesh = new THREE.Line(geometry, material);
                    scene.add(trailMesh);
                    trailMeshes.push(trailMesh);
                }
            });
        }

        function createIdentityMatrix(size) {
            const matrix = [];
            for (let i = 0; i < size; i++) {
                matrix[i] = [];
                for (let j = 0; j < size; j++) {
                    matrix[i][j] = (i === j) ? 1 : 0;
                }
            }
            return matrix;
        }

        function createGivensRotationMatrix(totalDimensions, dim1, dim2, piCoefficient) {
            const matrix = createIdentityMatrix(totalDimensions);

            // using pi Coefficient everywhere to avoid floating errors, using fixed precision because things that should be 0 are not 0
            const cos_angle = Number(Math.cos(piCoefficient*Math.PI).toFixed(10)) ;
            const sin_angle = Number(Math.sin(piCoefficient*Math.PI).toFixed(10)) ;

            matrix[dim1][dim1] = cos_angle;
            matrix[dim1][dim2] = -sin_angle;
            matrix[dim2][dim1] = sin_angle;
            matrix[dim2][dim2] = cos_angle;

            return matrix;
        }

        function multiplyMatrices(matrixA, matrixB) {
            const n = matrixA.length;
            const temp = [];

            for (let i = 0; i < n; i++) {
                temp[i] = [];
                for (let j = 0; j < n; j++) {
                    temp[i][j] = 0;
                    for (let k = 0; k < n; k++) {
                        temp[i][j] += matrixA[i][k] * matrixB[k][j];
                    }
                }
            }
            return temp
        }

        // Most intuitive approach: rotate around axis using Rodrigues' rotation formula concept
        function createIntuitiveAxisRotationMatrix(totalDimensions, axisIndices, piCoefficient, showDebug = false) {
            let matrix = createIdentityMatrix(totalDimensions);
            axisIndices = axisIndices.sort()// make sure we always rotate in the same order. Otherwise, the correct behaviour is to go haywire.
            axisIndices.forEach(axisIndex => {
                // For each axis, rotate all other coordinates around it
                // This creates a "barrel roll" effect around the specified axis

                // Get all dimensions except the axis
                const otherDimensions = [];
                for (let i = 0; i < totalDimensions; i++) {
                    if (i !== axisIndex) {
                        otherDimensions.push(i);
                    }
                }

                // Rotate pairs of other dimensions
                for (let i = 0; i < otherDimensions.length - 1; i += 1) {
                    for (let j = i+1; j < otherDimensions.length ; j += 1) {
                        if (i === j) {
                            continue;
                        }
                        const dim1 = otherDimensions[i];
                        const dim2 = otherDimensions[j];
                        const givensRotationMatrix = createGivensRotationMatrix(totalDimensions, dim1, dim2, piCoefficient);
                        if (showDebug){
                            console.log(`Givens rotation matrix for angle ${piCoefficient}  dimensions ${dim1} and ${dim2}:\n`, givensRotationMatrix.join('\n'));
                        }
                        matrix = multiplyMatrices(matrix, givensRotationMatrix);
                    }

                }
                if (showDebug){
                    console.log(`Matrix after rotating for angle ${piCoefficient} around axis ${axisIndex}:\n`, matrix.join('\n'));
                }
            });

            return matrix;
        }


        function multiplyPointByMatrix(point, matrix) {
            const coords = point.getCoordinates();
            const newCoords = [];

            for (let i = 0; i < coords.length; i++) {
                let sum = 0;
                for (let j = 0; j < coords.length; j++) {
                    sum += matrix[i][j] * coords[j];
                }
                newCoords[i] = sum;
            }


            return new NDimensionalPoint(...newCoords);

        }

        window.toggleRevolve = function() {
            try {
                if (!currentCollection) {
                    alert('Please generate points first!');
                    return;
                }

                const selectedDimensions = getSelectedDimensions();

                if (selectedDimensions.length === 0) {
                    alert('Please select at least one axis to rotate around!');
                    return;
                }

                if (isRevolving) {
                    // Stop revolving
                    stopRevolving();
                } else {
                    // Start revolving
                    startRevolving(selectedDimensions);
                }
            } catch (error) {
                console.error('Error in toggleRevolve:', error);
                alert('Error: ' + error.message);
            }
        }

        function startRevolving() {
//            createIntuitiveAxisRotationMatrix(baseCollection.getAllPoints()[0].getDimensions(), getSelectedDimensions(), 1/2,true);
//            createIntuitiveAxisRotationMatrix(baseCollection.getAllPoints()[0].getDimensions(), getSelectedDimensions(), 3/2,true);
            isRevolving = true;
            document.getElementById('revolveBtn').textContent = 'Stop Revolving';
            document.getElementById('revolveBtn').style.background = 'linear-gradient(145deg, #dc3545, #c82333)';
            document.getElementById('revolveBtn').style.boxShadow = '0 8px 16px rgba(220, 53, 69, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';

            // No need to calculate centroid - we're rotating around origin (0,0,0...)
            function animateRotation() {
                if (!isRevolving) return;

                try {
                    // Rotate around origin - no translation needed
                    currentCollection = rotateCollectionAroundOrigin(
                        currentCollection,
                        getSelectedDimensions(),
                        currentRotationStep
                    );
                    let distanceOfFirstPointToStart = currentCollection.getAllPoints()[0].distanceTo(baseCollection.getAllPoints()[0]);
                    // this is some exploratory code to find how many multiples of pi we need to rotate to get back to the start.  In 3d it's 2pi, but higher dimensions are more complex
                    if (distanceOfFirstPointToStart < .1) {
                        if (nearestApproach < distanceOfFirstPointToStart) {
                            nearestApproach = 1000;
                            //console.log('distance of first point ', distanceOfFirstPointToStart, '  rotation amount ', currentRotationAmount);
                        }else {
                            nearestApproach = distanceOfFirstPointToStart;
                        }
                    }
                    currentRotationAmount += currentRotationStep;

                    render3DPoints(currentCollection);
                    animationId = requestAnimationFrame(animateRotation);

                } catch (error) {
                    console.error('Error in animation:', error);
                    stopRevolving();
                }
            }

            animationId = requestAnimationFrame(animateRotation);

        }

        function stopRevolving() {
            isRevolving = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            updateRotationButtonState(); // Update button text and state
            console.log('Rotation stopped');
        }

        // Function to rotate collection around origin (no translation needed)
        function rotateCollectionAroundOrigin(collection) {
            const rotatedCollection = new PointCollection();
            for (let i = 0; i < collection.getAllPoints().length; i++) {
                const point = collection.getAllPoints()[i];
                const rotatedPoint = multiplyPointByMatrix(point, rotationMatrix);
                rotatedCollection.addPoint(rotatedPoint);
            }

            // Preserve lines from original collection
            if (collection.lines) {
                rotatedCollection.lines = collection.lines;
            }

            return rotatedCollection;
        }

        // Remove the old rotateCollectionAroundAxes function - it's no longer needed

        // Add cleanup when page is unloaded
        window.addEventListener('beforeunload', function() {
            stopRevolving();
        });

        // Optional: Add keyboard controls
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space' && currentCollection) {
                event.preventDefault();
                toggleRevolve();
            }
        });

        // Add window resize handler to update renderer size
        window.addEventListener('resize', function() {
            if (renderer && currentCollection && currentCollection.size() > 0) {
                const container = document.getElementById('canvas3d');
                const containerElement = document.getElementById('canvasContainer');
                const containerWidth = containerElement.clientWidth;
                const windowHeight = window.innerHeight;
                const containerTop = container.getBoundingClientRect().top;
                const availableHeight = windowHeight - containerTop - 20; // 20px for bottom margin

                // Use the smaller of available width or height to maintain square aspect ratio
                // Width accounts for 40px total padding (20px each side), height uses smaller margin
                containerSize = Math.min(containerWidth - 40, availableHeight);
                //containerSize = containerWidth;
//                console.log('windowHeight', window.innerHeight, ' window width', window.innerWidth, ' container heigh ', container.clientHeight, '   container width ', container.clientWidth);
                renderer.setSize(containerSize, containerSize);

                render3DPoints(currentCollection);
            }
        });


        window.updateRotationSpeed = function() {
            try {
                const slider = document.getElementById('speedSlider');
                const speedDisplay = document.getElementById('speedValue');

                rotationSpeed = parseFloat(slider.value);
                currentRotationStep = BASE_ROTATION_STEP * rotationSpeed;
                speedDisplay.textContent = rotationSpeed.toFixed(1) + 'x';
                nearestApproach = 1000;
                rotationMatrix = createIntuitiveAxisRotationMatrix(
                        currentCollection.getAllPoints()[0].getDimensions(),
                        getSelectedDimensions(),
                        currentRotationStep
                );

            } catch (error) {
                console.error('Error updating rotation speed:', error);
            }
        }

        window.updateZoom = function() {
            try {
                const slider = document.getElementById('zoomSlider');
                const valueDisplay = document.getElementById('zoomValue');

                const zoomLevel = parseFloat(slider.value);
                valueDisplay.textContent = zoomLevel.toFixed(2);

                // Re-render with new zoom
                if (currentCollection && currentCollection.size() > 0) {
                    render3DPoints(currentCollection);
                }

                //console.log('Zoom level updated to:', zoomLevel);
            } catch (error) {
                console.error('Error updating zoom:', error);
            }
        }

        // Generate points within unit n-dimensional sphere using rejection sampling
        function generatePointsInUnitSphere(numPoints, dimensions) {
            let pointsGenerated = 0;
            let attempts = 0;
            currentCollection.clear();
            const maxAttempts = numPoints * 100; // Prevent infinite loops

            while (pointsGenerated < numPoints && attempts < maxAttempts) {
                attempts++;

                // Generate random coordinates in [-1, 1] range
                const coordinates = [];
                for (let i = 0; i < dimensions; i++) {
                    coordinates.push((Math.random() - 0.5) * 2); // Random between -1 and 1
                }

                // Create point and check if it's within unit distance
                const point = new NDimensionalPoint(...coordinates);
                const distanceFromOrigin = point.magnitude(); // This calculates Euclidean distance from origin

                if (distanceFromOrigin <= 1.0) {
                    currentCollection.addPoint(point);
                    pointsGenerated++;
                }
            }

            if (pointsGenerated < numPoints) {
                console.warn(`Only generated ${pointsGenerated} out of ${numPoints} requested points after ${maxAttempts} attempts`);
                console.warn(`This can happen in high dimensions where the unit sphere occupies a very small fraction of the unit cube`);
            }
//            add the origin here so it's rendered with the rest of the points
            const originCoordinates = [];
            for (let i = 0; i < dimensions; i++) {
                originCoordinates.push(0);
            }
            currentCollection.addPoint(new NDimensionalPoint(...originCoordinates));

            console.log(`Generated ${pointsGenerated} points in ${attempts} attempts (${(pointsGenerated/attempts*100).toFixed(2)}% success rate)`);
        }

        // Function called when dimension checkbox is changed
        function onDimensionCheckboxChange() {

            // Get dimension name for logging
            // let dimensionName;
            // if (dimensionIndex === 0) dimensionName = 'X';
            // else if (dimensionIndex === 1) dimensionName = 'Y';
            // else if (dimensionIndex === 2) dimensionName = 'Z';
            // else dimensionName = `W${dimensionIndex-2}`;

            // Get all currently selected dimensions
            const selectedDimensions = getSelectedDimensions();

            // Update rotation if currently rotating
            if (isRevolving) {
                updateActiveRotation(selectedDimensions);
            }
            baseCollection = currentCollection.copy();
            currentRotationAmount = 0;
            nearestApproach = 1000;
            rotationMatrix = createIntuitiveAxisRotationMatrix(
                    currentCollection.getAllPoints()[0].getDimensions(),
                    getSelectedDimensions(),
                    currentRotationStep
            );


            // Update UI state
            updateRotationButtonState();
        }

        // Get all currently selected dimension indices
        function getSelectedDimensions() {
            const selectedDimensions = [];
            const checkboxes = document.querySelectorAll('#checkboxContainer input[type="checkbox"]:checked');

            checkboxes.forEach(checkbox => {
                selectedDimensions.push(parseInt(checkbox.value));
            });

            return selectedDimensions.sort((a, b) => a - b); // Sort for consistency
        }

        // Update the rotation button state based on selected dimensions
        function updateRotationButtonState() {
            const revolveBtn = document.getElementById('revolveBtn');
            const selectedDimensions = getSelectedDimensions();

            if (selectedDimensions.length === 0) {
                revolveBtn.disabled = true;
                revolveBtn.textContent = 'Select Axes to Rotate';
                revolveBtn.style.background = 'linear-gradient(145deg, #ccc, #aaa)';
                revolveBtn.style.cursor = 'not-allowed';
                revolveBtn.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';
            } else {
                revolveBtn.disabled = false;
                revolveBtn.style.cursor = 'pointer';

                if (isRevolving) {
                    revolveBtn.textContent = 'Stop Revolving';
                    revolveBtn.style.background = 'linear-gradient(145deg, #dc3545, #c82333)';
                    revolveBtn.style.boxShadow = '0 8px 16px rgba(220, 53, 69, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';
                } else {
                    const axesNames = selectedDimensions.map(dim => {
                        if (dim === 0) return 'X';
                        if (dim === 1) return 'Y';
                        if (dim === 2) return 'Z';
                        return `W${dim-2}`;
                    }).join(', ');
                    revolveBtn.textContent = `Rotate around ${axesNames}`;
                    revolveBtn.style.background = 'linear-gradient(145deg, #4a90e2, #357abd)';
                    revolveBtn.style.boxShadow = '0 8px 16px rgba(74, 144, 226, 0.4), 0 4px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3), inset 0 -1px 0 rgba(0, 0, 0, 0.2)';
                }
            }
        }

        // Update active rotation with new dimension selection
        function updateActiveRotation(selectedDimensions) {
            if (selectedDimensions.length === 0) {
                console.log('No dimensions selected - stopping rotation');
                stopRevolving();
                return;
            }

            // The rotation will automatically use the new selected dimensions
            // on the next animation frame since startRevolving reads from checkboxes
            console.log('Rotation will continue with new axes:', selectedDimensions);
        }

        // Add current position to each point's trail
        function updateTrails(points3D) {
            const showTrails = document.getElementById('showTrails').checked;
            if (!showTrails) return;

            // Get current zoom settings
            const zoomSlider = document.getElementById('zoomSlider');
            const zoomLevel = zoomSlider ? parseFloat(zoomSlider.value) : 0.15;

            points3D.forEach((point, index) => {
                // Store 3D coordinates directly
                const x3D = point.x * zoomLevel;
                const y3D = point.y * zoomLevel;
                const z3D = point.z * zoomLevel;

                // Get or create trail for this point
                if (!pointTrails.has(index)) {
                    pointTrails.set(index, []);
                }

                const trail = pointTrails.get(index);

                // Add current position to trail
                trail.push({
                    x: x3D,
                    y: y3D,
                    z: z3D,
                    timestamp: Date.now(),
                    distance: point.distanceFromViewpoint
                });

                // Limit trail length
                if (trail.length > maxTrailLength) {
                    trail.shift(); // Remove oldest point
                }
            });
        }



        window.updateTrailLength = function() {
            try {
                const slider = document.getElementById('trailLengthSlider');
                const valueDisplay = document.getElementById('trailLengthValue');

                maxTrailLength = parseInt(slider.value);
                valueDisplay.textContent = maxTrailLength.toString();

                // Trim existing trails to new length if they're longer
                pointTrails.forEach((trail) => {
                    if (trail.length > maxTrailLength) {
                        trail.splice(0, trail.length - maxTrailLength);
                    }
                });

                console.log('Trail length updated to:', maxTrailLength);
            } catch (error) {
                console.error('Error updating trail length:', error);
            }
        }

        // Add this function after the generatePointsInUnitSphere function
        function generateTesseract() {
            try {
                if (!NDimensionalPoint || !PointCollection) {
                    alert('JavaScript modules not loaded properly');
                    return;
                }

                // Get the number of dimensions from the input field
                const numDimensions = parseInt(document.getElementById('numDimensions').value);

                // Validate dimensions
                if (!numDimensions || numDimensions < 1) {
                    alert('Please enter a valid number of dimensions (at least 1)');
                    return;
                }

                if (numDimensions > 10) {
                    if (!confirm(`Generating a ${numDimensions}D cube will create ${Math.pow(2, numDimensions)} vertices. This might be slow. Continue?`)) {
                        return;
                    }
                }

                // Create PointCollection and clear previous data
                currentCollection = new PointCollection();
                pointTrails = new Map(); // Clear previous trails

                // Generate n-dimensional cube vertices (vertices at 1 for each dimension)
                const numVertices = Math.pow(2, numDimensions);
                const vertices = [];

                for (let i = 0; i < numVertices; i++) {
                    const coords = [];
                    for (let dim = 0; dim < numDimensions; dim++) {
                        // Use bit manipulation to determine coordinate value
                        coords.push((i & (1 << dim)) ? 1 : -1);
                    }
                    vertices.push(new NDimensionalPoint(...coords));
                    currentCollection.addPoint(new NDimensionalPoint(...coords));
                }

                // Generate n-dimensional cube edges
                // Two vertices are connected if they differ in exactly one coordinate
                const lines = [];
                for (let i = 0; i < numVertices; i++) {
                    for (let j = i + 1; j < numVertices; j++) {
                        // Count how many coordinates differ
                        let diffCount = 0;
                        for (let dim = 0; dim < numDimensions; dim++) {
                            if ((i & (1 << dim)) !== (j & (1 << dim))) {
                                diffCount++;
                            }
                        }

                        // Connect vertices that differ in exactly one coordinate
                        if (diffCount === 1) {
                            lines.push([i, j]);
                        }
                    }
                }

                // Add lines to collection
                currentCollection.lines = lines;

                // Add origin point for reference
                const originCoords = new Array(numDimensions).fill(0);
                currentCollection.addPoint(new NDimensionalPoint(...originCoords));

                // Update the points input to reflect the number of vertices
                document.getElementById('numPoints').value = numVertices;

                // Show dimension checkboxes
                updateDimensionCheckboxes();
                document.getElementById('dimensionCheckboxes').style.display = 'block';

                // Show and render 3D visualization
                document.getElementById('canvasContainer').style.display = 'block';
                document.getElementById('visualizationControls').style.display = 'block';
                render3DPoints(currentCollection);

                const dimensionName = numDimensions === 1 ? '1D line' : 
                                    numDimensions === 2 ? '2D square' : 
                                    numDimensions === 3 ? '3D cube' : 
                                    numDimensions === 4 ? '4D tesseract' : 
                                    `${numDimensions}D hypercube`;

                alert(`Successfully generated ${dimensionName} with ${numVertices} vertices and ${lines.length} edges!`);
            } catch (error) {
                console.error('Error in generateTesseract:', error);
                alert('Error generating n-dimensional cube: ' + error.message);
            }
        }

        window.generateTesseract = generateTesseract;
        window.dispatchEvent(new Event('resize'));
    </script>
</body>
</html>
